<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Richard de Rozario" />
  <meta name="date" content="2015-02-25" />
  <meta name="keywords" content="blog generator, R-code, pandoc, knitr" />
  <meta name="description" content="How to implement a mini blog site generator using R and pandoc. Only html and file folder structure is used to create and maintain a static blog for hosting on sites like GitHub. Aside from speed and simplicity, the advantage is that you can publish directly from R-markdown text." />
  <title>A mini blog generator in R with knitr and pandoc</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">A mini blog generator in R with knitr and pandoc</h1>
<h3 class="date">2015-02-25</h3>
</div>
<p>When I started blogging about analytics (and R), I went looking for a blogging platform that would allow me to easily post directly from R-markdown. However, the typical choices like Wordpress didn’t work well in that regard. I still had to copy, paste and edit the posts, because neither the markdown nor html features from extended markdown were well supported.</p>
<p>The solution pointed in the direction of “static blog generators”. These (re-)generate the blog as a set of ordinary html pages, which can then be hosted on places like <a href="https://github.com/">GitHub</a>. This means that you can just generate a html page from an R-markdown page, with something like <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>, save it in a folder, and sync the blog page with the host site. Writing a blog becomes almost seamless with writing some literate R.</p>
<p>I couldn’t find a simple blog generator written in R, so I wrote one.</p>
<p>So, this rather long blog documents a mini blog generator, written completely in R. The individual blog pages can be standalone html documents, like those generated by <a href="http://yihui.name/knitr/">knitr</a> and pandoc from R-markdown text. Each blog post consists of a folder that contains the html page, with a sub-folder for any graphics. The folder may also contain other files, which are ignored by the blog, but enables the folder to be a complete project folder, such as generated by <a href="http://www.rstudio.com/">RStudio</a>. The only restriction is the naming convention that the folder has the same name (minus extension) as the html page that contains the posting. So, an example structure of folders and files might be as follows:</p>
<figure>
<img src="figure/FolderStructure.png" /> <br>
<figcaption>
<em>Figure 1: example folder structure for the blog</em>
</figcaption>
</figure>
<p>In the example, the top folder<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> is called <code>username.github.io</code>. That is what you would choose for the top folder name, if you hosted your site using GitHub. That is, when you create an account on GitHub, you would also create a repository named <em>username.github.io</em><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> to host your blog, and that would automatically create a local folder by that name. If you do not host on GitHub, you may call the (local) folder anything you like.</p>
<p>The top folder also contains one essential file: <code>index.html</code>. This is just a straightforward html file, without any special “micro-templating” or “macros”. The miniblog generator that I’ll describe later simply updates this file whenever changes are made in the folders containing posts. Moreover, the generator only touches specific sections of the html, so you’re free to get creative with the other parts of the html. That way, you can style the layout of the blog site as you please.</p>
<p>One part that the blog generator changes in the html is the <code>iframe</code> that contains the front page article. This section looks like the following:</p>
<pre><code>
    &lt;!-- front page article -->
    &lt;iframe name="frontpost" class="frontpost" scrolling="auto" 
    frameborder="NO" src="posts/FirstArticle/FirstArticle.html">&lt;/iframe>
</code></pre>
<p>The generator replaces the <code>src</code> content to the html file of the last article that was updated. Similarly, the generator replaces the links <code>&lt;a...</code> links in the following section:</p>
<pre><code>
    &lt;!-- links to articles -->
    &lt;div class="articles">
    
    &lt;a href="posts/FirstArticle/FirstArticle.html"
    target="frontpost">FirstArticle&lt;/a>&lt;br>
    
    &lt;a href="posts/SecondArticle/SecondArticle.html"
    target="frontpost">SecondArticle&lt;/a>&lt;br>
    ...
    ...
    &lt;/div>
</code></pre>
<p>That’s it as far as the blog structure is concerned. An index.html file in the top folder and a sub-folder called “posts” that in turn contains a folder for each article. Articles are just html files that can be produced from something like an R-markdown text.</p>
<p>Now, onto the R-code that generates the blog site. Firstly, we require the XML libraries to handle the html files.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;XML&quot;</span>,<span class="dt">quietly=</span><span class="ot">TRUE</span>)
<span class="kw">require</span>(<span class="st">&quot;selectr&quot;</span>,<span class="dt">quietly=</span><span class="ot">TRUE</span>)</code></pre>
<p>Next is the function that “re-indexes” the front page. By that I mean, we want to scan all the articles in the <code>posts</code> folder and create the links for them in the <code>index.html</code> page. We also want to update the link for the front page article. The list of article links will be in order of last update.</p>
<p>The first parameter of the reindex function is the path to the top folder – that is, the folder where <code>index.html' lives.  In our example above, that might be something like</code>c:/GitHub/username.github.io/<code>.  The next parameter is the base URL that you would put in a browser to visit the blog -- for example,</code>http://username.github.io/`. The last parameter allows you to pass a metadata list – more about that later.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># recreate index.html with updated article list</span>
<span class="co"># assumes the path points to a folder structure</span>
<span class="co"># that adheres to the miniblog naming convention</span>
reindex &lt;-<span class="st"> </span>function(<span class="dt">path=</span><span class="st">&quot;./&quot;</span>,<span class="dt">base=</span><span class="st">&quot;&quot;</span>,<span class="dt">meta=</span><span class="ot">NA</span>){
    docpath &lt;-<span class="st"> </span><span class="kw">paste</span>(path,<span class="st">&quot;index.html&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)

    if(<span class="kw">file.exists</span>(docpath)){
        doc &lt;-<span class="st"> </span><span class="kw">htmlParse</span>(docpath)

        <span class="co"># get sorted article metadata</span>
    if(<span class="kw">typeof</span>(meta)!=<span class="st">&quot;list&quot;</span>) 
        meta &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(
            <span class="kw">metadata</span>(<span class="kw">paste</span>(path,<span class="st">&quot;posts/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>),
                     <span class="kw">paste</span>(base,<span class="st">&quot;posts/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
            )
        )
        p &lt;-<span class="st"> </span><span class="kw">order</span>(meta$mdate,<span class="dt">decreasing=</span><span class="ot">TRUE</span>)

        <span class="co"># replace links to articles</span>
        articles &lt;-<span class="st"> </span><span class="kw">querySelector</span>(doc,<span class="st">&quot;div .articles&quot;</span>)
        <span class="kw">removeNodes</span>(<span class="kw">xmlChildren</span>(articles))
        for(i in p){
            a &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;a&quot;</span>, <span class="kw">newXMLTextNode</span>(meta$post[i]), <span class="dt">attrs=</span><span class="kw">c</span>(
                    <span class="dt">href=</span> <span class="kw">paste</span>(<span class="st">&quot;posts/&quot;</span>,meta$relpath[i],<span class="dt">sep=</span><span class="st">&quot;&quot;</span>),
                    <span class="dt">target=</span><span class="st">&quot;frontpost&quot;</span>
                    )
                 )
            <span class="kw">addChildren</span>(articles,a)
            <span class="kw">addChildren</span>(articles,<span class="kw">newXMLNode</span>(<span class="st">&quot;br&quot;</span>))
        }
        
        <span class="co"># repoint front page article</span>
        f &lt;-<span class="st"> </span><span class="kw">querySelector</span>(doc,<span class="st">&quot;.frontpost&quot;</span>)
        <span class="kw">removeAttributes</span>(f,<span class="dt">.attrs=</span><span class="st">&quot;src&quot;</span>)
        <span class="kw">addAttributes</span>(f,<span class="dt">src=</span><span class="kw">paste</span>(<span class="st">&quot;posts/&quot;</span>,meta$relpath[p[<span class="dv">1</span>]],<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
    } else <span class="kw">warning</span>(<span class="kw">paste</span>(<span class="st">&quot;Index file does not exist: &quot;</span>, docpath,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
    <span class="kw">return</span>(doc)
}</code></pre>
<p>The function that gathers all the information about the articles is called <code>metadata()</code>. It gets a list of all the article folders in <code>posts</code> and then loops through them. In each folder it sucks in the html document and gathers all the meta data fields in the html header. It also checks the last modification date of the file, so that we can sort later by “latest update”. Finally, we also include the entire body of the html page, which is the content of the article. That’s where the most processing happens, because we have to replace the local image links with a full http reference, so that the content can stand alone from the location we gathered it from. Due to the transformations by the XML library functions, we also have to clean various special characters.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># function to read metadata from posts</span>
metadata &lt;-<span class="st"> </span>function(<span class="dt">path=</span><span class="st">&quot;./&quot;</span>,<span class="dt">base=</span><span class="st">&quot;&quot;</span>){
    <span class="co"># create a structure to hold info</span>
    meta &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">post=</span><span class="st">&quot;&quot;</span>, <span class="dt">relpath=</span><span class="st">&quot;&quot;</span>, <span class="dt">mdate=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;&quot;</span>, 
                 <span class="dt">author=</span><span class="st">&quot;&quot;</span>,<span class="dt">date=</span><span class="st">&quot;&quot;</span>, <span class="dt">description=</span><span class="st">&quot;&quot;</span>, <span class="dt">keywords=</span><span class="st">&quot;&quot;</span>,
                 <span class="dt">content=</span><span class="st">&quot;&quot;</span>)
                
    <span class="co"># get list of post html files</span>
    dirs &lt;-<span class="st"> </span><span class="kw">list.dirs</span>(path,<span class="dt">recursive=</span><span class="ot">FALSE</span>,<span class="dt">full.names=</span><span class="ot">FALSE</span>)
    postpaths &lt;-<span class="st"> </span><span class="kw">paste</span>(dirs,<span class="st">&quot;/&quot;</span>,dirs,<span class="st">&quot;.html&quot;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>)
    postfullpaths &lt;-<span class="st"> </span><span class="kw">paste</span>(path,postpaths,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>)
    
    <span class="co"># extract meta data from each file</span>
    for(i in <span class="dv">1</span>:<span class="kw">length</span>(postfullpaths)){
        if(<span class="kw">file.exists</span>(postfullpaths[i])){
            meta$post[i] &lt;-<span class="st"> </span>dirs[i]
            meta$relpath[i] &lt;-<span class="st"> </span>postpaths[i]
            meta$mdate[i] &lt;-<span class="st"> </span><span class="kw">file.info</span>(postfullpaths[i])$mtime 
            doc &lt;-<span class="st"> </span><span class="kw">htmlParse</span>(postfullpaths[i])
            <span class="kw">absolurl</span>(doc,<span class="dt">base=</span><span class="kw">paste</span>(base,dirs[i],<span class="st">&quot;/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
            xvalue &lt;-<span class="st"> </span><span class="kw">querySelector</span>(doc,<span class="st">&quot;title&quot;</span>)
            if(!<span class="kw">is.null</span>(xvalue)) meta$title[i] &lt;-<span class="st"> </span><span class="kw">xmlValue</span>(xvalue)
            meta$author[i] &lt;-<span class="st"> </span><span class="kw">metaval</span>(doc,<span class="st">&quot;author&quot;</span>)
            meta$date[i] &lt;-<span class="st"> </span><span class="kw">metaval</span>(doc,<span class="st">&quot;date&quot;</span>)
            meta$description[i] &lt;-<span class="st"> </span><span class="kw">metaval</span>(doc,<span class="st">&quot;description&quot;</span>)
            meta$keywords[i] &lt;-<span class="st"> </span><span class="kw">metaval</span>(doc,<span class="st">&quot;keywords&quot;</span>)
            
            <span class="co"># extract a clean-ish copy of the content</span>
            body &lt;-<span class="st"> </span><span class="kw">toString.XMLNode</span>(<span class="kw">querySelector</span>(doc,<span class="st">&quot;body&quot;</span>))
            body &lt;-<span class="st"> </span><span class="kw">substr</span>(body,<span class="dv">7</span>,<span class="kw">nchar</span>(body)-<span class="dv">8</span>)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;&amp;#13;&quot;</span>,<span class="st">&quot;&quot;</span>,body)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\x92</span><span class="st">&quot;</span>,<span class="st">&quot;&#39;&quot;</span>,body)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[</span><span class="ch">\x93</span><span class="st">-</span><span class="ch">\x94</span><span class="st">]&quot;</span>,<span class="st">&#39;&quot;&#39;</span>,body)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\x96</span><span class="st">&quot;</span>,<span class="st">&#39;&amp;mdash;&#39;</span>,body)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\x85</span><span class="st">&quot;</span>,<span class="st">&#39;&amp;#8230;&#39;</span>,body)
            body &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[</span><span class="ch">\x7f</span><span class="st">-</span><span class="ch">\xff</span><span class="st">]&quot;</span>,<span class="st">&#39; &#39;</span>,body)
            g &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;&lt;!--DISQUS&quot;</span>,body)[<span class="dv">1</span>] -<span class="st"> </span><span class="dv">1</span>
            if(g&gt;<span class="dv">0</span>) body &lt;-<span class="st"> </span><span class="kw">substr</span>(body,<span class="dv">1</span>,g)
            meta$content[i] &lt;-<span class="st"> </span>body
        }
    }
    <span class="kw">return</span>(meta)    
}</code></pre>
<p>The metadata function uses a special helper function for obtaining the value of a metadata field. That’s shown below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get a single metadata value</span>
metaval &lt;-<span class="st"> </span>function(xdoc,meta){
            r &lt;-<span class="st"> &quot;&quot;</span>
            xvalue &lt;-<span class="st"> </span><span class="kw">querySelector</span>(xdoc,<span class="kw">paste</span>(<span class="st">&quot;meta[name=&quot;</span>,meta,<span class="st">&quot;]&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
            if(!<span class="kw">is.null</span>(xvalue)) r &lt;-<span class="st"> </span><span class="kw">xmlGetAttr</span>(xvalue,<span class="st">&quot;content&quot;</span>,<span class="dt">default=</span><span class="st">&quot;&quot;</span>)
            <span class="kw">return</span>(r)
}</code></pre>
<p>The metadata function also grabs the content of the html page, which anticipates that we might want to generate an rss feed. However, the contents may contain relative links, for example to images. These links neeed to be made into absolute urls (i.e with full http path). The function below takes care of the main links. Essentially, it prefixes the base URL to the relative link in the attribute of the html tag.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># convert links in an xml node like &lt;body&gt; to </span>
<span class="co"># absolute references, using a base url</span>
absolurl &lt;-<span class="st"> </span>function(xml,<span class="dt">base=</span><span class="st">&quot;&quot;</span>){
    if(<span class="kw">substr</span>(base,<span class="kw">nchar</span>(base),<span class="kw">nchar</span>(base)) !=<span class="st"> &quot;/&quot;</span>) 
        base &lt;-<span class="st"> </span><span class="kw">paste</span>(base,<span class="st">&quot;/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)

    <span class="co"># expand and link (stylesheet) references</span>
    links &lt;-<span class="st"> </span><span class="kw">querySelectorAll</span>(xml,<span class="st">&quot;link&quot;</span>)
    for(i in links){
        link &lt;-<span class="st"> </span><span class="kw">xmlGetAttr</span>(i,<span class="st">&quot;href&quot;</span>,<span class="dt">default=</span><span class="st">&quot;&quot;</span>)
        if(link !=<span class="st"> &quot;&quot;</span> &amp;<span class="st"> </span><span class="kw">substr</span>(link,<span class="dv">1</span>,<span class="dv">4</span>) !=<span class="st"> &quot;http&quot;</span>){
            <span class="kw">removeAttributes</span>(i,<span class="dt">.attrs=</span><span class="st">&quot;href&quot;</span>)
            <span class="kw">addAttributes</span>(i,<span class="dt">href=</span><span class="kw">paste</span>(base,link,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
        }
    }

    <span class="co"># expand img links to absolute references</span>
    imgs &lt;-<span class="st"> </span><span class="kw">querySelectorAll</span>(xml,<span class="st">&quot;img&quot;</span>)
    for(i in imgs){
        link &lt;-<span class="st"> </span><span class="kw">xmlGetAttr</span>(i,<span class="st">&quot;src&quot;</span>,<span class="dt">default=</span><span class="st">&quot;&quot;</span>)
        if(link !=<span class="st"> &quot;&quot;</span> &amp;<span class="st"> </span><span class="kw">substr</span>(link,<span class="dv">1</span>,<span class="dv">4</span>) !=<span class="st"> &quot;http&quot;</span>){
            <span class="kw">removeAttributes</span>(i,<span class="dt">.attrs=</span><span class="st">&quot;src&quot;</span>)
            <span class="kw">addAttributes</span>(i,<span class="dt">src=</span><span class="kw">paste</span>(base,link,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
        }
    }
    
    <span class="co"># expand a a-links that do not have https or # prefix</span>
    anchors &lt;-<span class="st"> </span><span class="kw">querySelectorAll</span>(xml,<span class="st">&quot;a&quot;</span>)
    for(i in anchors){
        link &lt;-<span class="st"> </span><span class="kw">xmlGetAttr</span>(i,<span class="st">&quot;href&quot;</span>,<span class="dt">default=</span><span class="st">&quot;&quot;</span>)
        if(link !=<span class="st"> &quot;&quot;</span> &amp;<span class="st"> </span><span class="kw">substr</span>(link,<span class="dv">1</span>,<span class="dv">4</span>) !=<span class="st"> &quot;http&quot;</span> 
           &amp;<span class="st"> </span><span class="kw">substr</span>(link,<span class="dv">1</span>,<span class="dv">1</span>) !=<span class="st">&quot;#&quot;</span>){
            <span class="kw">removeAttributes</span>(i,<span class="dt">.attrs=</span><span class="st">&quot;href&quot;</span>)
            <span class="kw">addAttributes</span>(i,<span class="dt">src=</span><span class="kw">paste</span>(base,link,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
        }
    }
}</code></pre>
<p>Once we have all the meta-data, it’s relatively simple to generate an rss xml file. To take care of the xml pre-amble, we’ll just read a template file (or an existing rss file if it exists). Then, for each item in the meta data list, we’ll generate an xml node called <code>&lt;item&gt;</code>, which is how rss stores the article data. Note that if the metadata isn’t passed as a parameter, then we construct it within the <code>rssupdate</code> function, using the <code>path</code> and <code>base</code> parameters. This gives some flexibility to use the <code>rssupdate</code> function standalone, or as part of a larger process where we don’t want to duplicate reading the metadata.</p>
<p>Finally, the <code>rssupdate</code> function also allows for a rudimentary filtering on a keyword. This is useful if you want to create an rss feed for articles that contain a specific keyword. For example, if you put “R-code” as a keyword in your articles that contain R, you can then create a feed for <a href="http://www.r-bloggers.com/">R-bloggers</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># create rss feed</span>
rssupdate &lt;-<span class="st"> </span>function(filename,<span class="dt">meta=</span><span class="ot">NA</span>,<span class="dt">path=</span><span class="ot">NA</span>,<span class="dt">base=</span><span class="st">&quot;&quot;</span>,<span class="dt">keyword=</span><span class="ot">NA</span>){
    <span class="co"># get sorted post metadata</span>
    if(<span class="kw">typeof</span>(meta)!=<span class="st">&quot;list&quot;</span>) 
        meta &lt;-<span class="st"> </span><span class="kw">metadata</span>(<span class="kw">paste</span>(path,<span class="st">&quot;posts/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>),<span class="dt">base=</span>base)
    meta &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(meta)
    if(!<span class="kw">is.na</span>(keyword)) p &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">grepl</span>(keyword,meta$keywords))
    else p &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="kw">nrow</span>(meta)
    
    <span class="co"># rss preamble</span>
    doc &lt;-<span class="st"> </span><span class="kw">xmlParse</span>(<span class="kw">paste</span>(path,filename,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
    url &lt;-<span class="st"> </span><span class="kw">xmlValue</span>(<span class="kw">querySelector</span>(doc,<span class="st">&quot;link&quot;</span>))
    if(<span class="kw">substr</span>(url,<span class="kw">nchar</span>(url),<span class="kw">nchar</span>(url)) !=<span class="st"> &quot;/&quot;</span>) url &lt;-<span class="st"> </span><span class="kw">paste</span>(url,<span class="st">&quot;/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
    
    channel &lt;-<span class="st"> </span><span class="kw">xmlParent</span>(<span class="kw">querySelector</span>(doc,<span class="st">&quot;item&quot;</span>))
    <span class="kw">removeNodes</span>(<span class="kw">querySelectorAll</span>(doc,<span class="st">&quot;item&quot;</span>))
    
    <span class="co"># create new item nodes</span>
    for(i in p){
        a &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;item&quot;</span>)
        title &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;title&quot;</span>, <span class="kw">newXMLTextNode</span>(meta$title[i]))
        link &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;link&quot;</span>, <span class="kw">newXMLTextNode</span>(
            <span class="kw">paste</span>(url,<span class="st">&quot;posts/&quot;</span>,meta$relpath[i],<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
        ))
        guid &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;guid&quot;</span>, <span class="kw">newXMLTextNode</span>(
            <span class="kw">paste</span>(url,<span class="st">&quot;posts/&quot;</span>,meta$relpath[i],<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
        ))
        pubDate &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;pubDate&quot;</span>, <span class="kw">newXMLTextNode</span>(
            <span class="kw">format</span>(<span class="kw">as.POSIXct</span>(meta$date[i]),<span class="st">&quot;%a, %d %b %Y %H:%M:%S %z&quot;</span>)
        ))
        description &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;description&quot;</span>, <span class="kw">newXMLTextNode</span>(
            meta$description[i]
        ))
        content &lt;-<span class="st"> </span><span class="kw">newXMLNode</span>(<span class="st">&quot;content:encoded&quot;</span>, 
            <span class="kw">newXMLTextNode</span>(meta$content[i], <span class="dt">cdata=</span><span class="ot">TRUE</span>
        ))
        <span class="kw">addChildren</span>(channel,a)
        <span class="kw">addChildren</span>(a,<span class="dt">kids =</span> 
            <span class="kw">list</span>(title,link,guid,pubDate,description,content)
        )
    }
    <span class="kw">return</span>(doc)
}</code></pre>
<p>Finally, we use all the functions above in a “blog update” function. The function rewrites the <code>index.html</code> page and creates rss files.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># rewrite the index.html page of the blog</span>
<span class="co"># incl. making a backup copy </span>
blogupdate &lt;-<span class="st"> </span>function(<span class="dt">path=</span><span class="st">&quot;./&quot;</span>,<span class="dt">base=</span><span class="st">&quot;&quot;</span>){
    curdir &lt;-<span class="st"> </span><span class="kw">getwd</span>()
    <span class="kw">setwd</span>(path)
    <span class="kw">file.copy</span>(<span class="dt">from=</span><span class="st">&quot;index.html&quot;</span>,<span class="dt">to=</span><span class="st">&quot;index.html.old&quot;</span>,<span class="dt">overwrite=</span><span class="ot">TRUE</span>)
    meta &lt;-<span class="st"> </span><span class="kw">metadata</span>(<span class="dt">path=</span><span class="st">&quot;posts/&quot;</span>,<span class="dt">base=</span><span class="kw">paste</span>(base,<span class="st">&quot;posts/&quot;</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>))
    doc &lt;-<span class="st"> </span><span class="kw">reindex</span>(path,<span class="dt">meta=</span>meta)
    <span class="kw">saveXML</span>(doc,<span class="st">&quot;index.html&quot;</span>)
    <span class="kw">saveXML</span>(<span class="kw">rssupdate</span>(<span class="st">&quot;template.xml&quot;</span>,<span class="dt">path=</span>path,<span class="dt">meta=</span>meta),<span class="st">&quot;all.xml&quot;</span>)
    <span class="kw">saveXML</span>(<span class="kw">rssupdate</span>(<span class="st">&quot;template.xml&quot;</span>,<span class="dt">path=</span>path,<span class="dt">keyword=</span><span class="st">&quot;R-code&quot;</span>,<span class="dt">meta=</span>meta),<span class="st">&quot;rcode.xml&quot;</span>)
    <span class="kw">setwd</span>(curdir)   
}</code></pre>
<p>That’s it – just create literate R articles in folders underneath the <code>posts</code> folder and run the <code>blogupdate</code> function. You then need to sync your files with the host site and that depends on where you’re hosting your blog. If it is on GitHub then just use the relevant <code>git</code> command like “push” (or on Windows, the <code>sync</code> button).</p>
<div class="references">

</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’m using Windows terminology of “folders” here, of course meaning “directories” for nix fans.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>where <em>username</em> is your GitHub username.<a href="#fnref2">↩</a></p></li>
</ol>
</div>

<!--DISQUS DON'T REMOVE THIS COMMENT-->
 <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'richardderozario'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
    
 <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'richardderozario'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</body>
</html>
